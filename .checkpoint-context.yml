---
schema_version: "1"
timestamp: "2025-10-24T10:24:53-07:00"
context:
    problem_statement: Implementing two-tier context system to maintain LLM development continuity
    key_insights:
        - insight: Context discontinuity is the primary challenge in LLM-assisted development
          impact: Capturing 'why' decisions were made enables effective session resumption and consistent decision-making
          scope: project
        - insight: Two-tier context (point-in-time + project-wide) manages LLM context window size
          impact: Project file stays small and focused while checkpoint context preserves full history
          scope: project
        - insight: Human curation is essential for project-level context quality
          impact: Automated aggregation would create noise; human judgment maintains signal
          scope: project
    decisions_made:
        - decision: Split context into checkpoint-specific and project-wide files
          rationale: Keeps LLM context manageable (project + recent entries) while preserving full historical detail
          alternatives_considered:
            - Single aggregated context file
            - Automated context summarization
          constraints_that_influenced: LLM context window limits and need for both detail and manageability
          scope: project
        - decision: Use append-only recommendations queue in project file
          rationale: Avoids automation complexity while providing helpful suggestions that human can review and incorporate
          alternatives_considered:
            - Automated merging of project-scoped items
            - Separate recommendations file
          constraints_that_influenced: Human responsibility for curation quality, need for simple workflow
          scope: project
        - decision: Include commit_hash in context entries for linking
          rationale: Allows correlation between context, changelog, and git history
          scope: checkpoint
        - decision: Pre-populate all project document fields with examples
          rationale: Provides clear structure and guidance for human curators
          scope: checkpoint
    established_patterns:
        - pattern: Multi-document YAML for consumption doc + recommendation queue
          rationale: First document stays clean for LLM consumption, subsequent docs provide curation suggestions
          examples: .checkpoint-project.yml structure with main doc followed by recommendations per checkpoint
          scope: project
        - pattern: Context items marked with scope field to indicate checkpoint vs project applicability
          rationale: Enables automatic extraction of project-level recommendations while keeping checkpoint-specific details separate
          examples: key_insights, decisions_made, failed_approaches, established_patterns all support scope field
          scope: project
    conversation_context:
        - exchange: Discussed whether context belongs in changelog or separate file - decided separate
          outcome: Context has different lifecycle and consumption pattern than changelog; separation maintains clarity
        - exchange: Questioned whether to automate project file updates - decided against
          outcome: Human curation is essential for quality; tool provides recommendations as queue for review
        - exchange: Debated context file format and line length restrictions
          outcome: Context uses .yml extension with relaxed line lengths for detailed explanations
        - exchange: Identified that language detection belongs in meta document as project characteristic
          outcome: Led to understanding that some context is project-level, some is checkpoint-level
---
schema_version: "1"
timestamp: "2025-10-24T10:57:48-07:00"
context:
    problem_statement: Completing project schema with comprehensive structured fields and fixing context correlation mechanism
    key_insights:
        - insight: Commit hash is only needed in changelog, not context or project files
          impact: Simplifies correlation model - timestamp alone links entries across all files
          scope: project
        - insight: Comprehensive project schema enables complete project understanding
          impact: 'All aspects of project captured: dependencies, targets, testing, roles, constraints'
          scope: project
        - insight: Explicit examples in templates guide LLM behavior effectively
          impact: Inline examples prevent confusion about checkpoint vs project scope
          scope: project
    decisions_made:
        - decision: Use timestamp-only correlation instead of backfilling hashes to multiple files
          rationale: Only changelog participates in git commit, so only it needs the hash; timestamp is sufficient for linking across files
          alternatives_considered:
            - Backfill commit hash to all three files
            - Use ULID or other correlation ID
          constraints_that_influenced: Context and project files don't stage/commit with changelog, making hash backfill complex
          scope: project
        - decision: Add all 10 new schema sections in single checkpoint
          rationale: Complete schema provides full project characterization; partial implementation would leave gaps
          alternatives_considered:
            - Implement sections incrementally
            - Wait to see which sections are actually needed
          constraints_that_influenced: Schema should be comprehensive from the start for LLM understanding
          scope: checkpoint
        - decision: Backport complete schema to existing project file
          rationale: Existing project file should demonstrate the full schema with real checkpoint-specific values
          scope: checkpoint
    failed_approaches:
        - approach: Initially included commit_hash in context entries
          why_failed: Unnecessary complexity - only changelog needs hash since it's the only file staged/committed
          lessons_learned: Correlation mechanism should match the actual workflow, not add unnecessary fields
          scope: project
    established_patterns:
        - pattern: Comprehensive structured schemas with inline examples in templates
          rationale: Reduces LLM confusion by providing explicit guidance and examples for each field
          examples: Context template now includes examples of checkpoint vs project scope for each field type
          scope: project
        - pattern: Timestamp-based correlation across append-only files
          rationale: Single source of truth (timestamp) links entries without complex backfill mechanisms
          examples: Changelog, context, and project files all use matching timestamps to correlate entries
          scope: project
    conversation_context:
        - exchange: Identified that commit_hash was incorrectly added to context entries
          outcome: Removed hash from context schema and eliminated backfill code - only changelog needs it
        - exchange: Discussed which project schema sections are most valuable
          outcome: Implemented all 10 suggested sections for comprehensive project characterization
        - exchange: Questioned whether LLM would understand new fields without context
          outcome: Added detailed instructions, complete section list, and inline examples to context template
        - exchange: Considered whether to backport new schema to existing project file
          outcome: Updated existing file with all new fields and checkpoint-specific real values
---
schema_version: "1"
timestamp: "2025-10-28T13:04:19-07:00"
context:
    problem_statement: LLM incorrectly attempted to run 'checkpoint check' before implementing any code changes, revealing missing workflow guidance for session start
    key_insights:
        - insight: Workflow needs explicit session entry point that validates state and guides next steps
          impact: Prevents confusion about when to run which command; makes workflow self-teaching
          scope: project
        - insight: Commands that call os.Exit are hard to test
          impact: Extract testable internal implementation that returns success/failure bool
          scope: project
    decisions_made:
        - decision: Create 'start' command as first command of each work session
          rationale: Validates readiness (git repo, checkpoint init, no conflicts), shows context (next steps), guides user to next action
          alternatives_considered:
            - Add --status flag to check command
            - Just improve documentation
          constraints_that_influenced: Need to catch workflow errors early; documentation alone isn't enough for LLMs
          scope: project
        - decision: Show warnings but don't fail on non-critical issues
          rationale: Pending recommendations or changes in working directory shouldn't block starting work
          alternatives_considered:
            - Fail on any non-clean state
          scope: checkpoint
    failed_approaches:
        - approach: Initially tried to mock os.Exit in tests
          why_failed: Mock approach is fragile and doesn't test actual behavior
          lessons_learned: Better pattern is public wrapper that calls testable internal implementation
          scope: project
    established_patterns:
        - pattern: Commands should have both public wrapper and testable internal implementation
          rationale: Allows comprehensive testing without mocking os.Exit or other system calls
          examples: Start() calls startInternal() which returns bool; same pattern should apply to other commands that call os.Exit
          scope: project
        - pattern: Start command as session entry point
          rationale: Validates state, shows context, guides next action - makes workflow explicit
          examples: Run 'checkpoint start' at beginning of each work session
          scope: project
    conversation_context:
        - exchange: User correctly identified that I misunderstood the workflow by running 'checkpoint check' before doing any work
          outcome: Realized need for explicit 'start' command that validates readiness and explains what to do. This is Checkpoint 0 - improving the workflow itself.
        - exchange: Discussed whether to fail on warnings (in-progress checkpoint, pending recommendations)
          outcome: Decided warnings shouldn't block start - they're informational. Only errors (no git, no init) should prevent starting work.
        - exchange: Question about how to count checkpoints in changelog
          outcome: Realized document separators (---) are the correct approach; first separator marks meta doc, subsequent ones mark checkpoints
---
schema_version: "1"
timestamp: "2025-10-28T13:31:04-07:00"
context:
    problem_statement: Input file was too large (460+ lines) due to embedded project context and recent context, making it difficult to edit and causing tool failures. Also needed to establish organized directory structure for supporting materials per Checkpoint 1 plan.
    key_insights:
        - insight: Input file should be minimal and focused on what needs to be filled
          impact: Keeps input file manageable (~170 lines vs 460+), easier to edit, prevents tool failures. LLM can read source files directly when needed.
          scope: project
        - insight: Supporting materials need organized structure separate from root
          impact: Clean separation between data files (root) and documentation/examples (.checkpoint/ directory)
          scope: project
    decisions_made:
        - decision: Remove project_context, recent_context, and languages from input template
          rationale: These are reference materials that bloat the file but aren't used by commit. LLM can read .checkpoint-project.yml and .checkpoint-context.yml directly when filling input.
          alternatives_considered:
            - Keep embedded but compress/summarize
            - Move to separate reference file that check creates
          constraints_that_influenced: Edit tool struggled with 460+ line files; human user found it unwieldy
          scope: project
        - decision: Create .checkpoint/ directory with subdirectories in init command
          rationale: Provides organized location for examples, guides, prompts, and templates. Tracked in git so structure is preserved.
          alternatives_considered:
            - Flat .checkpoint/ directory
            - Multiple top-level dot directories
          constraints_that_influenced: Need clean root directory; examples and guides need logical organization
          scope: checkpoint
    established_patterns:
        - pattern: Reference files by path in comments rather than embedding content
          rationale: Keeps files focused and manageable; users/LLMs can read full files when needed
          examples: Input template now has comments pointing to .checkpoint-project.yml and .checkpoint-context.yml
          scope: project
    conversation_context:
        - exchange: User questioned why project context was in input file and whether it was needed at commit time
          outcome: Realized project context was only reference material for filling, not used by commit. Led to removing all embedded reference material.
        - exchange: User noticed edit tool had difficulty with the large input file
          outcome: Confirmed that 460+ line input file was problematic; reduced to ~170 lines by removing embedded contexts
---
schema_version: "1"
timestamp: "2025-10-28T13:41:41-07:00"
context:
    problem_statement: Users and LLMs need concrete examples of well-structured checkpoints to calibrate their work. Without examples, checkpoint quality varies widely and users don't know what 'good' looks like.
    key_insights:
        - insight: Examples teach better than instructions
          impact: Concrete examples with annotations show exactly what to aim for; more effective than abstract guidelines
          scope: project
        - insight: Anti-patterns are as valuable as good patterns
          impact: Showing common mistakes helps users avoid them; complements positive examples
          scope: project
        - insight: 'Examples should cover full spectrum: features, bugs, refactors, context'
          impact: Different types of work need different checkpoint approaches; comprehensive examples cover all cases
          scope: checkpoint
    decisions_made:
        - decision: Create 5 distinct example files rather than one comprehensive file
          rationale: Easier to reference specific types; users can view just what they need; keeps each file focused
          alternatives_considered:
            - Single examples.yaml with all examples (rejected - too long, hard to navigate)
            - Embed examples in CHECKPOINT.md (rejected - keeps examples separate from workflow docs)
          constraints_that_influenced: Examples need to be easily viewable via command; file size should be manageable
          scope: checkpoint
        - decision: Include extensive annotations in examples explaining what makes them good
          rationale: Self-teaching - examples explain themselves; helps users understand the 'why' behind patterns
          scope: project
        - decision: Use realistic scenarios (JWT auth, memory leaks, validation) not toy examples
          rationale: Real-world examples are more relatable and show how to handle actual complexity
          scope: checkpoint
    established_patterns:
        - pattern: Examples include 'what makes this good' annotations
          rationale: Makes examples self-teaching; users learn principles not just see format
          examples: Each example file ends with checklist of good practices demonstrated
          scope: project
        - pattern: Command with optional category argument for progressive disclosure
          rationale: List categories first, then drill into specifics; reduces cognitive load
          examples: checkpoint examples (list) vs checkpoint examples feature (show)
          scope: project
    conversation_context:
        - exchange: Discussed whether to generate examples programmatically or write manually
          outcome: Manual writing chosen - examples need nuance and annotations that generation can't provide
        - exchange: Questioned how much detail to include in examples
          outcome: Decided on comprehensive detail - better to have rich examples users can simplify than sparse examples they must augment
---
schema_version: "1"
timestamp: "2025-10-28T13:54:34-07:00"
context:
    problem_statement: Users and LLMs need comprehensive documentation to understand checkpoint workflow, best practices, and integration patterns. Examples alone aren't enough - need narrative guides explaining how and why.
    key_insights:
        - insight: 'Guides serve different audiences: first-time users need quick start, LLMs need workflow integration, everyone needs best practices'
          impact: Three distinct guides cover the full spectrum of use cases without overwhelming any single audience
          scope: project
        - insight: Documentation should be self-contained in .checkpoint/ directory
          impact: All resources available locally; no external dependencies or web docs needed
          scope: project
        - insight: Real-world examples in guides make concepts concrete
          impact: Guides include specific scenarios, command outputs, and YAML examples throughout
          scope: checkpoint
    decisions_made:
        - decision: Create three focused guides rather than one comprehensive manual
          rationale: Different users need different information; focused guides reduce cognitive load and make specific topics easier to find
          alternatives_considered:
            - Single comprehensive manual (rejected - too overwhelming for new users)
            - Many small guides (rejected - harder to find information, duplication)
          constraints_that_influenced: Need to serve first-time users, experienced users, and LLMs with different needs
          scope: project
        - decision: Write guides in Markdown for readability and portability
          rationale: Markdown is human-readable as plain text, renders nicely in editors/viewers, easy to edit
          alternatives_considered:
            - YAML format (rejected - less readable for long-form content)
            - HTML (rejected - harder to edit, requires browser)
          scope: checkpoint
        - decision: Include extensive examples and templates in guides
          rationale: Learn by example - show specific YAML, commands, workflows rather than just describing them
          scope: project
    established_patterns:
        - pattern: Guides include both concept explanation and concrete examples
          rationale: Theory + practice = effective learning; readers can understand why and see how
          examples: Each major concept in guides followed by example YAML, command output, or workflow
          scope: project
        - pattern: Documentation organized by audience and use case
          rationale: Makes it easy to find relevant information; reduces time to value
          examples: first-time-user.md for newcomers, llm-workflow.md for LLM integration, best-practices.md for ongoing use
          scope: project
    conversation_context:
        - exchange: Discussed whether to include guide command in this checkpoint
          outcome: Decided to create guides first, command in next checkpoint - establishes content before building command to display it
        - exchange: Questioned how much detail to include in guides
          outcome: Comprehensive detail chosen - guides are reference material, users can skim but depth available when needed
---
schema_version: "1"
timestamp: "2025-10-28T14:02:26-07:00"
context:
    problem_statement: Guides were created but not easily accessible. Users need commands to view them, and CHECKPOINT.md should direct users to detailed resources rather than trying to be comprehensive itself.
    key_insights:
        - insight: Commands make documentation discoverable and accessible
          impact: Users can easily find and view guides without knowing file paths; mirrors examples command for consistency
          scope: project
        - insight: CHECKPOINT.md should be quick reference, not comprehensive manual
          impact: Restructured to point to detailed resources; users get oriented quickly then dive deeper as needed
          scope: project
    decisions_made:
        - decision: Implement guide command with same pattern as examples command
          rationale: Consistent UX - users already familiar with examples pattern can immediately use guide command
          alternatives_considered:
            - Different command structure (rejected - consistency more valuable)
            - Combine with examples command (rejected - conceptually different enough to warrant separate command)
          constraints_that_influenced: Want consistency across discovery commands
          scope: project
        - decision: Restructure CHECKPOINT.md as quick reference with links
          rationale: Users need rapid orientation, not comprehensive docs; point to detailed resources for depth
          alternatives_considered:
            - Expand CHECKPOINT.md to be comprehensive (rejected - becomes overwhelming)
            - Minimal CHECKPOINT.md (rejected - need enough context for basic understanding)
          scope: checkpoint
    established_patterns:
        - pattern: 'Discovery commands follow consistent pattern: list all, show specific'
          rationale: Progressive disclosure - overview first, details on demand; consistent UX across commands
          examples: checkpoint examples [category], checkpoint guide [topic]
          scope: project
        - pattern: 'Documentation has layers: quick reference → guides → examples'
          rationale: Different depth for different needs; users can choose their level of detail
          examples: CHECKPOINT.md → .checkpoint/guides/ → .checkpoint/examples/
          scope: project
    conversation_context:
        - exchange: Discussed whether to combine guide and examples commands
          outcome: Kept separate - conceptually different (narrative guides vs concrete examples); easier to discover with distinct commands
---
schema_version: "1"
timestamp: "2025-10-28T14:08:00-07:00"
context:
    problem_statement: Developers and LLMs need rapid project orientation at session start. Existing 'checkpoint start' shows status checks but not historical context or recent patterns. Summary command provides comprehensive overview in one place.
    key_insights:
        - insight: Summary aggregates data from multiple sources for holistic view
          impact: Single command provides project state, history, and direction without reading multiple files
          scope: project
        - insight: Relative time formatting makes activity timeline intuitive
          impact: Users immediately understand recency ('4 minutes ago' vs '2025-10-28T14:02:26')
          scope: project
        - insight: Recent patterns from context show project evolution
          impact: Developers see what conventions have been established recently, maintaining consistency
          scope: checkpoint
    decisions_made:
        - decision: Show last 5 checkpoints in recent activity
          rationale: Enough to show recent trajectory without overwhelming; matches typical short-term memory
          alternatives_considered:
            - Last 3 (rejected - too few for context)
            - Last 10 (rejected - too many, loses focus)
          constraints_that_influenced: Terminal screen space; typical session length
          scope: checkpoint
        - decision: Support --json flag for machine-readable output
          rationale: Enables integration with other tools, scripts, and potentially macOS app
          alternatives_considered:
            - Human-only output (rejected - limits automation)
            - Always JSON (rejected - poor human UX)
          scope: project
        - decision: Extract project-level patterns from recent context entries
          rationale: Shows what conventions have been established; helps maintain consistency
          scope: checkpoint
    established_patterns:
        - pattern: Commands support --json for machine-readable output
          rationale: Enables scripting and integration while maintaining human-friendly default
          examples: 'checkpoint summary --json, future: checkpoint context --json'
          scope: project
        - pattern: Relative time formatting for human readability
          rationale: Humans understand 'yesterday' better than ISO timestamps
          examples: formatTimeAgo() function converts RFC3339 to relative format
          scope: project
    conversation_context:
        - exchange: Discussed how much historical data to show
          outcome: Last 5 checkpoints balances context with brevity; patterns from last 3 context entries focuses on recent
        - exchange: Questioned whether to include project file recommendations count
          outcome: Yes - reminds users to curate; low-friction way to surface pending work
