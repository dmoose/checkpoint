---
schema_version: "1"
project_name: checkpoint
last_updated: "2025-10-24T10:26:14-07:00"
key_insights:
  - insight: Minimal dependencies philosophy drives most architectural decisions
    rationale: Maintains tool reliability and reduces external failure points
  - insight: Context discontinuity is the primary challenge in LLM-assisted development
    rationale: Capturing 'why' decisions were made enables effective session resumption
  - insight: Two-tier context (point-in-time + project-wide) manages LLM context window size
    rationale: Project file stays small while checkpoint context preserves full history
established_patterns:
  - pattern: Append-only file structures for all historical data
    rationale: Prevents corruption, enables incremental processing, maintains complete history
    examples: changelog, context files, project recommendations
  - pattern: Multi-document YAML for consumption doc + recommendation queue
    rationale: First document stays clean for LLM consumption, subsequent docs provide suggestions
    examples: .checkpoint-project.yml structure
  - pattern: Table-driven tests for scenario coverage
    rationale: Comprehensive testing with minimal code duplication
    examples: language detection tests, numstat parsing tests
failed_approaches:
design_principles:
  - principle: Separate temporary files from tracked files
    rationale: Clean git history, clear intent about data lifecycle
    applies_to: input files (temp), output files (tracked)
  - principle: Human curation for project-level context
    rationale: Automated aggregation creates noise; human judgment maintains signal
    applies_to: project document maintenance
  - principle: Explicit error handling over silent failures
    rationale: CLI tools need clear error reporting for user troubleshooting
    applies_to: all command implementations
integration_points:
  - system: macOS Swift app
    interaction: Reads changelog and context files for daily summaries
    requirements: YAML multi-document format, consistent schema versions
    constraints: Files must be parseable independently of Go CLI
code_patterns:
  - preference: Struct-based configuration over global variables
    rationale: Testability and clear data flow
    examples: CheckpointEntry, MetaDocument, Language structs
  - preference: Explicit error returns with helpful hints
    rationale: Users need actionable guidance when things fail
    examples: All command error messages include hints
dependencies:
  - name: gopkg.in/yaml.v3
    purpose: YAML parsing for multi-document files
    version_constraint: v3.0.1 or compatible
    rationale: Must support multi-document format for append-only files
    alternatives_considered: Standard library encoding/yaml (lacks multi-doc support)
  - name: github.com/oklog/ulid/v2
    purpose: Generate unique sortable project IDs
    version_constraint: v2.1.1 or compatible
    rationale: Time-ordered unique IDs for project identification
    alternatives_considered: UUID (not time-sortable), timestamps (collision risk)
language_requirements:
  - language: Go
    minimum_version: "1.25"
    rationale: Uses newer standard library features and modern error handling patterns
deployment_targets:
  - platform: macOS
    minimum_version: "10.15"
    architectures: ["arm64", "amd64"]
    rationale: CLI tool targets modern macOS for M1/M2 and Intel Macs
  - platform: Linux
    minimum_version: "kernel 3.10+"
    architectures: ["amd64", "arm64"]
    rationale: Should run on common Linux servers and development machines
  - platform: Windows
    minimum_version: "10"
    architectures: ["amd64"]
    rationale: Support Windows developers with WSL or native execution
testing_methodologies:
  - approach: Table-driven tests for multiple scenarios
    rationale: Comprehensive coverage with minimal code duplication
    examples: language detection, numstat parsing, validation
    coverage_target: "80%+ for core packages"
  - approach: Integration tests with temporary git repositories
    rationale: Verify complete workflow in realistic conditions
    examples: complete workflow test, concurrent checkpoint prevention
  - approach: Unit tests for all packages
    rationale: Fast feedback on isolated functionality
    examples: schema validation, file operations, git commands
development_roles:
  - role: Human Developer
    responsibilities: System architecture and design decisions
    workflow: Requests analysis and recomendations from llm, approves plan, reviews results
  - role: LLM Agent
    responsibilities: Competent Senior software engineer
    workflow: Comprehensive analysis of existing code and requirements, report to developer, respond to feedback with implementation plan, when approved execute plan, at appropriate points stop to allow developer to provide feedback and check/commit current state
  - role: Human Developer
    responsibilities: Run check/commit commands, curate project file, review LLM suggestions
    workflow: Initiates checkpoints, maintains project context quality, reviews recommendations
  - role: LLM Agent
    responsibilities: Fill checkpoint input including context section, generate project recommendations
    workflow: Analyzes changes, captures reasoning, suggests project-level patterns
  - role: macOS App
    responsibilities: Discover projects, read changelog/context files, generate daily summaries
    workflow: Passive consumer of checkpoint data for visualization and reporting
error_handling_patterns:
  - pattern: Explicit error returns with context, no panics in CLI commands
    rationale: User-facing tool needs graceful degradation and helpful messages
    examples: File I/O errors, git command failures, validation errors
  - pattern: Tolerate missing optional files (context, project) for progressive enhancement
    rationale: Tool works even without full context, enabling gradual adoption
    examples: check command works without existing context files
  - pattern: Provide hints in error messages for resolution
    rationale: Users need actionable guidance to fix issues
    examples: All error messages include hint field with suggested actions
compatibility_strategy:
  - principle: Schema version field in all documents
    rationale: Enables future migrations and multi-version support
    migration_path: Read old versions, write current version, migrate on write
  - principle: Additive changes only to YAML schemas
    rationale: New fields use omitempty; old readers ignore unknown fields
    migration_path: Never remove fields, only add with backward-compatible defaults
  - principle: Maintain append-only semantics
    rationale: Historical data never modified, only appended
    migration_path: New schema versions append, never rewrite history
file_management:
  - file: .checkpoint-changelog.yaml
    lifecycle: Created by init, appended by commit, never deleted
    ownership: Tool-managed, human readable
    tracked_in_git: true
  - file: .checkpoint-context.yml
    lifecycle: Created on first commit, appended per checkpoint
    ownership: Tool-managed, human readable
    tracked_in_git: true
  - file: .checkpoint-project.yml
    lifecycle: Created by init, recommendations appended by commit, main doc human-curated
    ownership: Human-curated with tool assistance
    tracked_in_git: true
  - file: .checkpoint-input
    lifecycle: Generated per checkpoint, deleted after commit
    ownership: Tool-generated, LLM/human edited
    tracked_in_git: false
  - file: .checkpoint-diff
    lifecycle: Generated per checkpoint, deleted after commit
    ownership: Tool-generated, informational only
    tracked_in_git: false
  - file: .checkpoint-status.yaml
    lifecycle: Updated per commit for macOS app discovery
    ownership: Tool-managed
    tracked_in_git: false
security_considerations:
  - concern: No sensitive data in tracked changelog/context files
    mitigation: Files are git-tracked; users must not include credentials or PII
    guidance: Review checkpoint input before commit; use environment variables for secrets
  - concern: File permissions for checkpoint artifacts
    mitigation: Standard 0644 permissions; rely on filesystem security
    guidance: Ensure repository access controls are properly configured
  - concern: Command injection through git operations
    mitigation: Use exec.Command with separate arguments, never shell interpolation
    guidance: All git commands use array arguments, not string concatenation
performance_considerations:
  - aspect: Context file growth over time
    impact: Linear growth with checkpoint count, O(n) file size
    mitigation: Recent-only loading (last 4 entries) keeps memory bounded
    threshold: Acceptable up to ~1000 checkpoints before considering archival
  - aspect: Project file size with uncurated recommendations
    impact: Grows with each checkpoint if recommendations not curated
    mitigation: Human regularly reviews and prunes recommendation queue
    threshold: Review when recommendations exceed 20-30 entries
  - aspect: Language detection filesystem traversal
    impact: O(n) where n is number of files in project
    mitigation: Skip common ignore patterns (node_modules, vendor, .git)
    threshold: Acceptable for projects up to 100k files
cross_cutting_concerns:
  - concern: Timezone handling
    approach: Always use RFC3339 with timezone; preserve local time
    rationale: Enables correlation across time zones for distributed teams
  - concern: File encoding
    approach: UTF-8 for all files
    rationale: Universal support, handles international characters in context
  - concern: Line endings
    approach: Unix LF, let git handle conversion via autocrlf
    rationale: Standard for CLI tools, git handles platform differences
  - concern: YAML formatting
    approach: Use yaml.v3 with default formatting
    rationale: Consistent formatting across all checkpoint files
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-24T10:57:48-07:00"
recommended_additions:
  key_insights:
    - insight: Commit hash is only needed in changelog, not context or project files
      rationale: Simplifies correlation model - timestamp alone links entries across all files
    - insight: Comprehensive project schema enables complete project understanding
      rationale: "All aspects of project captured: dependencies, targets, testing, roles, constraints"
    - insight: Explicit examples in templates guide LLM behavior effectively
      rationale: Inline examples prevent confusion about checkpoint vs project scope
  established_patterns:
    - pattern: Comprehensive structured schemas with inline examples in templates
      rationale: Reduces LLM confusion by providing explicit guidance and examples for each field
      examples: Context template now includes examples of checkpoint vs project scope for each field type
    - pattern: Timestamp-based correlation across append-only files
      rationale: Single source of truth (timestamp) links entries without complex backfill mechanisms
      examples: Changelog, context, and project files all use matching timestamps to correlate entries
  failed_approaches:
    - approach: Initially included commit_hash in context entries
      why_failed: Unnecessary complexity - only changelog needs hash since it's the only file staged/committed
      lessons_learned: Correlation mechanism should match the actual workflow, not add unnecessary fields
  design_principles:
    - principle: Use timestamp-only correlation instead of backfilling hashes to multiple files
      rationale: Only changelog participates in git commit, so only it needs the hash; timestamp is sufficient for linking across files
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T13:04:19-07:00"
recommended_additions:
    key_insights:
        - insight: Workflow needs explicit session entry point that validates state and guides next steps
          rationale: Prevents confusion about when to run which command; makes workflow self-teaching
        - insight: Commands that call os.Exit are hard to test
          rationale: Extract testable internal implementation that returns success/failure bool
    established_patterns:
        - pattern: Commands should have both public wrapper and testable internal implementation
          rationale: Allows comprehensive testing without mocking os.Exit or other system calls
          examples: Start() calls startInternal() which returns bool; same pattern should apply to other commands that call os.Exit
        - pattern: Start command as session entry point
          rationale: Validates state, shows context, guides next action - makes workflow explicit
          examples: Run 'checkpoint start' at beginning of each work session
    failed_approaches:
        - approach: Initially tried to mock os.Exit in tests
          why_failed: Mock approach is fragile and doesn't test actual behavior
          lessons_learned: Better pattern is public wrapper that calls testable internal implementation
    design_principles:
        - principle: Create 'start' command as first command of each work session
          rationale: Validates readiness (git repo, checkpoint init, no conflicts), shows context (next steps), guides user to next action
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T13:31:04-07:00"
recommended_additions:
    key_insights:
        - insight: Input file should be minimal and focused on what needs to be filled
          rationale: Keeps input file manageable (~170 lines vs 460+), easier to edit, prevents tool failures. LLM can read source files directly when needed.
        - insight: Supporting materials need organized structure separate from root
          rationale: Clean separation between data files (root) and documentation/examples (.checkpoint/ directory)
    established_patterns:
        - pattern: Reference files by path in comments rather than embedding content
          rationale: Keeps files focused and manageable; users/LLMs can read full files when needed
          examples: Input template now has comments pointing to .checkpoint-project.yml and .checkpoint-context.yml
    design_principles:
        - principle: Remove project_context, recent_context, and languages from input template
          rationale: These are reference materials that bloat the file but aren't used by commit. LLM can read .checkpoint-project.yml and .checkpoint-context.yml directly when filling input.
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T13:41:41-07:00"
recommended_additions:
    key_insights:
        - insight: Examples teach better than instructions
          rationale: Concrete examples with annotations show exactly what to aim for; more effective than abstract guidelines
        - insight: Anti-patterns are as valuable as good patterns
          rationale: Showing common mistakes helps users avoid them; complements positive examples
    established_patterns:
        - pattern: Examples include 'what makes this good' annotations
          rationale: Makes examples self-teaching; users learn principles not just see format
          examples: Each example file ends with checklist of good practices demonstrated
        - pattern: Command with optional category argument for progressive disclosure
          rationale: List categories first, then drill into specifics; reduces cognitive load
          examples: checkpoint examples (list) vs checkpoint examples feature (show)
    design_principles:
        - principle: Include extensive annotations in examples explaining what makes them good
          rationale: Self-teaching - examples explain themselves; helps users understand the 'why' behind patterns
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T13:54:34-07:00"
recommended_additions:
    key_insights:
        - insight: 'Guides serve different audiences: first-time users need quick start, LLMs need workflow integration, everyone needs best practices'
          rationale: Three distinct guides cover the full spectrum of use cases without overwhelming any single audience
        - insight: Documentation should be self-contained in .checkpoint/ directory
          rationale: All resources available locally; no external dependencies or web docs needed
    established_patterns:
        - pattern: Guides include both concept explanation and concrete examples
          rationale: Theory + practice = effective learning; readers can understand why and see how
          examples: Each major concept in guides followed by example YAML, command output, or workflow
        - pattern: Documentation organized by audience and use case
          rationale: Makes it easy to find relevant information; reduces time to value
          examples: first-time-user.md for newcomers, llm-workflow.md for LLM integration, best-practices.md for ongoing use
    design_principles:
        - principle: Create three focused guides rather than one comprehensive manual
          rationale: Different users need different information; focused guides reduce cognitive load and make specific topics easier to find
        - principle: Include extensive examples and templates in guides
          rationale: Learn by example - show specific YAML, commands, workflows rather than just describing them
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T14:02:26-07:00"
recommended_additions:
    key_insights:
        - insight: Commands make documentation discoverable and accessible
          rationale: Users can easily find and view guides without knowing file paths; mirrors examples command for consistency
        - insight: CHECKPOINT.md should be quick reference, not comprehensive manual
          rationale: Restructured to point to detailed resources; users get oriented quickly then dive deeper as needed
    established_patterns:
        - pattern: 'Discovery commands follow consistent pattern: list all, show specific'
          rationale: Progressive disclosure - overview first, details on demand; consistent UX across commands
          examples: checkpoint examples [category], checkpoint guide [topic]
        - pattern: 'Documentation has layers: quick reference → guides → examples'
          rationale: Different depth for different needs; users can choose their level of detail
          examples: CHECKPOINT.md → .checkpoint/guides/ → .checkpoint/examples/
    design_principles:
        - principle: Implement guide command with same pattern as examples command
          rationale: Consistent UX - users already familiar with examples pattern can immediately use guide command
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T14:08:00-07:00"
recommended_additions:
    key_insights:
        - insight: Summary aggregates data from multiple sources for holistic view
          rationale: Single command provides project state, history, and direction without reading multiple files
        - insight: Relative time formatting makes activity timeline intuitive
          rationale: Users immediately understand recency ('4 minutes ago' vs '2025-10-28T14:02:26')
    established_patterns:
        - pattern: Commands support --json for machine-readable output
          rationale: Enables scripting and integration while maintaining human-friendly default
          examples: 'checkpoint summary --json, future: checkpoint context --json'
        - pattern: Relative time formatting for human readability
          rationale: Humans understand 'yesterday' better than ISO timestamps
          examples: formatTimeAgo() function converts RFC3339 to relative format
    design_principles:
        - principle: Support --json flag for machine-readable output
          rationale: Enables integration with other tools, scripts, and potentially macOS app
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-10-28T15:39:48-07:00"
recommended_additions:
    key_insights:
        - insight: Simple regex-based variable substitution is sufficient for prompt templates rather than full templating engines
          rationale: Keeps the system simple and predictable with no hidden behaviors. Unknown variables become empty strings without errors, matching user expectations.
        - insight: Init command must be safe to run multiple times in existing projects
          rationale: Allows newer versions of checkpoint to add new resources (prompts, guides) without destroying user data or requiring manual file creation
        - insight: CHECKPOINT.md should always be updated since it's documentation, not user data
          rationale: Users get latest workflow guidance when running init, but their actual checkpoint data remains untouched
    established_patterns:
        - pattern: Follow examples/guide command patterns for new list/show commands
          rationale: Consistent UX across similar commands - list when no arg, show specific item when arg provided
          examples: Applied to prompt command, mirrors guide and examples commands
        - pattern: Comprehensive test coverage for new packages
          rationale: Test-driven approach ensures correctness and makes refactoring safer
          examples: prompts_test.go has 10+ test cases covering all major functionality
    design_principles:
        - principle: 'Three-tier variable priority: CLI args > global vars > automatic vars'
          rationale: Allows project defaults in prompts.yaml to be overridden per-use with --var flags, while automatic variables like project_name are always available
        - principle: Init command checks file existence before creating
          rationale: Makes init safe to run in existing projects to add new features (prompts, guides) without destroying user data like changelog or project files
---
schema_version: "1"
document_type: recommendations
timestamp: "2025-11-03T19:14:42-08:00"
recommended_additions:
    design_principles:
        - principle: Never write .checkpoint-* from MCP
          rationale: Preserve append-only guarantees; CLI remains sole writer
---
schema_version: "1"
document_type: recommendations
timestamp: "2026-01-12T09:38:19-08:00"
recommended_additions:
    key_insights:
        - insight: 'Zsh completion requires #compdef on first line for autoloading'
          rationale: Must use specific directive format, not arbitrary comments
        - insight: Tool independence is the key value proposition for LLM-assisted development
          rationale: README should emphasize that context travels with project, not locked in any tool
    established_patterns:
        - pattern: internal/detect package for project auto-detection
          rationale: Separates detection logic from init command, reusable by doctor
          examples: DetectProject() returns ProjectInfo with language, commands, frameworks
    design_principles:
        - principle: Auto-detect project settings in init rather than requiring templates
          rationale: Better UX - works out of the box for common project types
---
schema_version: "1"
document_type: recommendations
timestamp: "2026-01-12T13:20:13-08:00"
recommended_additions:
    key_insights:
        - insight: Cobra's self-registering init() pattern eliminates centralized command routing
          rationale: Adding new commands now requires only creating a single file with init() registration
    established_patterns:
        - pattern: Cobra command registration via init()
          rationale: Each cmd/*.go file registers itself, no central routing needed
          examples: rootCmd.AddCommand(checkCmd) in cmd/check.go init()
        - pattern: Options struct per command for flags
          rationale: Groups related flags, avoids global variable pollution
          examples: var skillOpts struct { json bool } with skillCmd.Flags().BoolVar()
    design_principles:
        - principle: Adopt Cobra as CLI framework
          rationale: Industry standard for Go CLIs, eliminates boilerplate, provides built-in completions, help, and flag parsing
        - principle: Use --json flag pattern for machine-readable output
          rationale: Consistent flag name across commands, optional to preserve human-friendly default
---
schema_version: "1"
document_type: recommendations
timestamp: "2026-01-12T14:04:16-08:00"
recommended_additions:
    key_insights:
        - insight: 'Session and next_steps serve different purposes: ephemeral planning vs historical record'
          rationale: Keep both - session for active planning, next_steps in checkpoint for permanent history
        - insight: Plan mode (explicit planning phase) improves complex task execution
          rationale: LLMs work better when they plan before coding; session enables this workflow
    established_patterns:
        - pattern: Session file cleared on commit, preserved with --keep-session
          rationale: Clean slate for new work unit; explicit flag for multi-commit sessions
          examples: checkpoint commit clears session; checkpoint commit --keep-session preserves
        - pattern: Rich task tracking with status in session next_actions
          rationale: 'Enables progress tracking: pending → in_progress → done/blocked'
          examples: next_actions[].status field with blocked_by for dependencies
    design_principles:
        - principle: Session is ephemeral - cleared on commit by default
          rationale: Completed work unit should start fresh. Historical record lives in changelog next_steps.
---
schema_version: "1"
document_type: recommendations
timestamp: "2026-01-12T14:27:04-08:00"
recommended_additions:
    key_insights:
        - insight: Templates should be self-documenting - include all fields with placeholder prompts
          rationale: LLMs can understand and use features without needing external documentation in context
    established_patterns:
        - pattern: Templates include all valid fields with placeholder prompts
          rationale: Makes schema discoverable from the file itself without external documentation
          examples: Session template shows progress, blockers, decisions, learnings with example structure
    design_principles:
        - principle: Include all schema fields in template with placeholder prompts
          rationale: Self-documenting templates reduce assumptions about what context the LLM has access to
